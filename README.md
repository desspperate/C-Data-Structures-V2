# C Data Structures V2

Библиотека структур данных на языке C, реализующая базовые коллекции с динамическим управлением памятью.

## Описание

Проект предоставляет реализацию следующих структур данных:
- **Динамический массив (arr)** - массив с автоматическим расширением
- **Хеш-таблица (hashmap)** - ассоциативный контейнер на основе хеширования

Библиотека поддерживает работу с произвольными типами данных через указатели `void*` и предоставляет механизмы для управления памятью объектов.

## Структура проекта

```
.
├── src/                    # Исходный код библиотеки
│   ├── arr.c              # Реализация динамического массива
│   ├── arr_static.c       # Статическая версия массива
│   ├── hashmap.c          # Реализация хеш-таблицы
│   ├── hashmap_static.c   # Статическая версия хеш-таблицы
│   └── include/           # Заголовочные файлы
│       ├── arr.h          # API динамического массива
│       └── hashmap.h      # API хеш-таблицы
├── tests/                 # Тесты (Google Test)
│   ├── main.cpp           # Точка входа для тестов
│   ├── arr.cpp            # Тесты для массива
│   └── hashmap.cpp        # Тесты для хеш-таблицы
├── bin/                   # Скомпилированные файлы (генерируется)
├── compilelib.py          # Скрипт компиляции библиотеки
└── runtests.py            # Скрипт запуска тестов
```

## API

### Динамический массив (arr)

```c
// Создание массива с начальной емкостью
arr *arr_init(size_t initial_cap);

// Добавление элемента в конец массива
int arr_append(arr *array, void *obj);

// Получение элемента по индексу
void *arr_get(arr *array, size_t index);

// Удаление и возврат последнего элемента
void *arr_pop(arr *array);

// Получение текущей длины массива
size_t arr_len(arr *array);

// Получение текущей емкости массива
size_t arr_cap(arr *array);

// Получение внутреннего массива
void **arr_inner(arr *array);

// Очистка массива (без освобождения объектов)
int arr_clear(arr *array);

// Освобождение памяти массива
int arr_free(arr *array);

// Освобождение массива и всех объектов
int arr_super_free(arr *array);
```

### Хеш-таблица (hashmap)

```c
// Создание хеш-таблицы
hashmap *hashmap_init(
    size_t init_cap,              // Начальная емкость
    float expand_at,              // Коэффициент расширения (0.0-1.0)
    int (*hash_code)(void*),      // Функция хеширования
    int (*keys_eq)(void*, void*), // Функция сравнения ключей
    int (*free_pair)(void*)       // Функция освобождения пар
);

// Добавление/обновление пары ключ-значение
int hashmap_put(hashmap *hashmap_, void *key, void *val);

// Получение значения по ключу
void *hashmap_get(hashmap *hashmap_, void *key);

// Очистка хеш-таблицы
int hashmap_clear(hashmap *hashmap_);

// Освобождение хеш-таблицы
int hashmap_free(hashmap *hashmap_);

// Освобождение хеш-таблицы и всех объектов
int hashmap_super_free(hashmap *hashmap_);
```

## Сборка

### Компиляция библиотеки

Для сборки разделяемой библиотеки (shared library):

```bash
python3 compilelib.py
```

Это создаст файл `bin/libdspdatastructures-0.01v.so`.

### Компиляция и запуск тестов

Для запуска тестов с использованием Google Test:

```bash
python3 runtests.py
```

Скрипт:
- Компилирует тесты с AddressSanitizer для проверки утечек памяти
- Запускает тестовый исполняемый файл
- Выводит код возврата

## Требования

- **Компилятор**: GCC или совместимый компилятор C/C++
- **Python**: 3.x (для скриптов сборки)
- **Google Test**: для запуска тестов
- **AddressSanitizer**: для проверки корректности работы с памятью

## Особенности

- **Типобезопасность**: использование `void*` позволяет хранить любые типы данных
- **Управление памятью**: поддержка пользовательских функций освобождения памяти
- **Автоматическое расширение**: динамические структуры автоматически увеличивают емкость
- **Тестирование**: покрытие тестами с проверкой утечек памяти через AddressSanitizer

## Пример использования

```c
#include "arr.h"
#include <stdio.h>

int main() {
    // Создание массива с начальной емкостью 10
    arr *my_array = arr_init(10);

    // Добавление элементов
    int *value = malloc(sizeof(int));
    *value = 42;
    arr_append(my_array, value);

    // Получение элемента
    int *retrieved = (int*)arr_get(my_array, 0);
    printf("Value: %d\n", *retrieved);

    // Освобождение памяти
    arr_super_free(my_array);

    return 0;
}
```

## Лицензия

Проект распространяется как есть для образовательных и исследовательских целей.

## Автор

desspperate